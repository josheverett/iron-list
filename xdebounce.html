<link rel="import" href="../polymer/src/utils/boot.html">
<link rel="import" href="../polymer/src/utils/utils.html">

<script>
  Polymer.XDebouncer = function XDebouncer() {
    this._scheduler = Polymer.XAsync.microTask;
    this._timer = null;
    this._wait = 0;
    this.flush = this.flush.bind(this);
  };

  Polymer.Utils.mixin(Polymer.XDebouncer.prototype, {
    after: function(scheduler, wait) {
      this._scheduler = scheduler;
      this._wait = wait;
      return this;
    },
    run: function(callback, context) {
      this._callback = context ? callback.bind(context) : callback;
      this._timer = this._scheduler.run(this.flush, this._wait);
      return this;
    },
    cancel: function() {
      if (this.isActive()) {
        this._scheduler.cancel(this._timer);
        this._timer = null;
      }
      return this;
    },
    flush: function() {
      if (this.isActive()) {
        this.cancel();
        this._callback();
      }
      return this;
    },
    isActive: function() {
      return this._timer != null;
    }
  });

  Polymer.XDebouncer.debounce = function(debouncer) {
    return debouncer ? debouncer.cancel() : new Polymer.XDebouncer();
  };

  Polymer.XAsync = {};

  Polymer.XAsync.timeOut = {
    run: window.setTimeout.bind(window),
    cancel: window.clearTimeout.bind(window)
  };

  Polymer.XAsync.rAF = {
    run:  window.requestAnimationFrame.bind(window),
    cancel: window.cancelAnimationFrame.bind(window)
  };

  Polymer.XAsync.rIC = {
    run: function(fn) {
      var g = window;
      return g.requestIdleCallback ? g.requestIdleCallback(fn) : setTimeout(fn, 16);
    },
    cancel: function(timer) {
      var g = window;
      g.cancelIdleCallback ? g.cancelIdleCallback(timer) : clearTimeout(timer);
    }
  };

  Polymer.XAsync.microTask = {
    _currVal: 0,
    _lastVal: 0,
    _callbacks: [],
    _twiddleContent: 0,
    _twiddle: document.createTextNode(''),
    run: function (callback) {
      this._twiddle.textContent = this._twiddleContent++;
      this._callbacks.push(callback);
      return this._currVal++;
    },
    cancel: function(handle) {
      var idx = handle - this._lastVal;
      if (idx >= 0) {
        if (!this._callbacks[idx]) {
          throw 'invalid async handle: ' + handle;
        }
        this._callbacks[idx] = null;
      }
    },
    _atEndOfMicrotask: function() {
      var len = this._callbacks.length;
      for (var i=0; i<len; i++) {
        var cb = this._callbacks[i];
        if (cb) {
          try {
            cb();
          } catch(e) {
            // Clear queue up to this point & start over after throwing
            i++;
            this._callbacks.splice(0, i);
            this._lastVal += i;
            this._twiddle.textContent = this._twiddleContent++;
            throw e;
          }
        }
      }
      this._callbacks.splice(0, len);
      this._lastVal += len;
    },
    flush: function() {
      this.observer.takeRecords();
      this._atEndOfMicrotask();
    }
  };
  Polymer.XAsync.microTask.observer = new window.MutationObserver(function() {
    Polymer.XAsync.microTask._atEndOfMicrotask();
  });
  Polymer.XAsync.microTask.observer.observe(Polymer.XAsync.microTask._twiddle, {characterData: true});

  // this.job = Polymer.Debouncer.debounce(this.job).after(Polymer.Async.timeOut, 16).run(cb);
  // this.job = Polymer.Debouncer.debounce(this.job).after(Polymer.Async.microTask).run(cb);
  // this.job = Polymer.Debouncer.debounce(this.job).after(Polymer.Async.rAF).run(cb);
  // this.job = Polymer.Debouncer.debounce(this.job).after(Polymer.Async.rIC).run(cb);

  // Polymer.Templatizer.enqueueDebouncer(this.job);
  // Polymer.Templatizer.flush();
</script>